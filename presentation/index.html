<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Paya League Answers - Final Round</title>
    <link rel="stylesheet" href="css/index.css" />
    <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/11.6.0/styles/atom-one-light.min.css">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans&display=swap" rel="stylesheet">
</head>

<body>
    <!-- Page 1 -->
    <section class="page page-1">
        <div class="center">
            <h3 class="subject">به نام خدا</h3>
            <br>
            <h1 class="subject">پاسخ سوالات لیگ علمی پایا</h1>
            <h2 class="subject">مقطع علوم کامپیوتر و برنامه نویسی</h1>
            <h3 class="year">سال تحصیلی: ۱۴۰۰ - ۱۴۰۱</h3>
            <h3 class="subheading">مرحله نهایی</h2>
            <br>
            <h4 class="people">اعضای تیم: ماهان لامعی، علی آتش روز، امیرمحمد غضنفری، طاها تعصب</h3>
        </div>
    </section>

    <!-- Page 2 -->
    <section class="page page-2">
        <h3 class="page-heading">سوال ۱:</h2>
        <pre>
        <code class="language-cpp">#include &lt;algorithm&gt;
#include &lt;future&gt;
#include &lt;iostream&gt;
#include &lt;math.h&gt;
#include &lt;thread&gt;
#include &lt;vector&gt;
#include &lt;string.h&gt;

using namespace std;

const auto CORE_COUNT = thread::hardware_concurrency();

inline bool isPrime(int num);
inline int reverse(int num);
inline bool isEmirp(int num);
vector&lt;int&gt; find_emirps(vector&lt;int&gt;&amp; source_primes, bool multithreaded = true);
vector&lt;int&gt; primes_in_range(int start, int end, bool multithreaded = true);

// A global vector of primes, so that we don't have to regenerate primes every time we use some functions
vector&lt;int&gt; check_primes;

bool multithread_enable = true;

inline bool isPrime(int num)
{
    if (num == 1) {
        return false;
    }
    if (num &lt; 4) {
        return true;
    }
    // If primes list is not passed to the function, generate them
    int num_sqrt = sqrt(num);
    if (check_primes.size() == 0 || check_primes.back() &lt; num_sqrt) {
        check_primes = primes_in_range(0, num_sqrt, multithread_enable);
    }
    for (int i = 0; i &lt; check_primes.size(); i++) {
        // Stop when we reach the square root of number
        if (check_primes[i] &gt; num_sqrt)
            break;
        if (num % check_primes[i] == 0)
            return false;
    }
    return true;
}
// Reverses a number, eg. 586 --&gt; 685
inline int reverse(int num)
{
    int remainder = 0, reversed_number = 0;
    while (num != 0) {
        remainder = num % 10;
        reversed_number = reversed_number * 10 + remainder;
        num /= 10;
    }
    return reversed_number;
}

inline bool isEmirp(int num)
{
    return isPrime(reverse(num));
}
// Find all the primes from start to end (containing both start and end if they are prime)
vector&lt;int&gt; primes_in_range(int start, int end, bool multithreaded)
{
    vector&lt;int&gt; primes;
    // Do multi-threading if its worth it
    if (multithreaded &amp;&amp; end - start &gt; 1000) {
        int count = end - start + 1;
        vector&lt;future&lt;vector&lt;    padding-top: 10px;
        padding-bottom: 10px;
        padding-left: 10px;reads don't respect order
        sort(primes.begin(), primes.end());

    } else {
        // If we are doing classical sieve (starting from 0)
        if (start &lt;= 2) {
            // The sieve bool array
            vector&lt;bool&gt; sieve(end + 1, true);
            // Remove even numbers except 2
            for (int i = 4; i &lt; sieve.size(); i += 2) {
                sieve[i] = false;
            }
            // Remove multiples of 3 except 3 itself
            for (int i = 9; i &lt; sieve.size(); i += 6) {
                sieve[i] = false;
            }
            // 0 and 1 are not prime
            sieve[0] = sieve[1] = false;
            // For each odd number less than sqrt(end) starting from 5 (2 and 3 are already done)...
            for (int i = 5; i &lt;= sqrt(end); i += 2) {
                // If i is prime
                if (sieve[i]) {
                    // Start from i^2 and remove all multiples of i (auto skipping even numbers)
                    for (int j = pow&lt;int, int&gt;(i, 2); j &lt; sieve.size(); j += i * 2) {
                        sieve[j] = false;
                    }
                }
            }
            // Add 2 as a prime (so we can skip all evens in the next loop)
            primes.insert(primes.end(), 2);
            // Add all primes (skipping even numbers, and 2 is already added) to the primes vector
            for (int i = 3; i &lt; sieve.size(); i += 2) {
                if (sieve[i]) {
                    primes.insert(primes.end(), i);
                }
            }
        } else {
            // Segmented sieve
            int count = end - start + 1;
            // The sieve array (offset by start, meaning sieve[0] is the start and sieve.back() is the end)
            vector&lt;bool&gt; sieve(count, true);
            // Remove even numbers
            for (int i = start % 2; i &lt; sieve.size(); i += 2) {
                sieve[i] = false;
            }
            // Calculate primes before sqrt(end)
            vector&lt;int&gt; primes_until_sqrt = primes_in_range(0, sqrt(end), multithreaded);
            // For all the primes except 2 (even numbers are already removed)...
            for (int i = 1; i &lt; primes_until_sqrt.size(); i++) {
                // Remove all the multiples of this prime
                for (int j = max&lt;int&gt;(ceil(static_cast&lt;double&gt;(start) / primes_until_sqrt[i]), primes_until_sqrt[i]); j &lt;= end / primes_until_sqrt[i]; j++) {
                    sieve[(primes_until_sqrt[i] * j) - start] = false;
                }
            }
            // Add all the primes (auto skipping evens)
            for (int i = !(start % 2); i &lt; sieve.size(); i += 2) {
                if (sieve[i]) {
                    primes.insert(primes.end(), i + start);
                }
            }
        }
    }
    // Primes array now has all the primes from start and end
    return primes;
}

vector&lt;int&gt; find_emirps(vector&lt;int&gt;&amp; source_primes, bool multithreaded)
{
    vector&lt;int&gt; emirps;
    // If the vector is worth multi-threading
    if (multithreaded &amp;&amp; source_primes.size() &gt; 100) {
        // Futures vector
        vector&lt;future&lt;vector&lt;int&gt;&gt;&gt; futures;
        // Keep a reference of subdivision vectors on the heap
        vector&lt;vector&lt;int&gt;*&gt; subdivisions;
        // Number of elments in each segment, segments smaller than 100 are not worth it
        int division_size = max&lt;int&gt;(100, source_primes.size() / CORE_COUNT);
        // Create the prime numbers segment and start the threads
        for (int start_index = 0; start_index &lt; source_primes.size(); start_index++) {
            // Each range starts from i to 1 less than the next segment
            int end_index = min&lt;int&gt;(source_primes.size() - 1, start_index + division_size - 1);
            vector&lt;int&gt;* subdivision = new vector&lt;int&gt;(source_primes.begin() + start_index, source_primes.begin() + end_index + 1);
            subdivisions.insert(subdivisions.end(), subdivision);
            start_index = end_index;
            futures.insert(futures.end(), async(find_emirps, ref(*subdivision), false));
        }
        // Get thread results
        for (auto&amp; f : futures) {
            auto result = f.get();
            emirps.insert(emirps.end(), result.begin(), result.end());
        }
        // Delete subdivision vectors from the heap
        for (auto sub : subdivisions) {
            delete sub;
        }
        // Sort the array, since threads do not work by order
        sort(emirps.begin(), emirps.end());
    } else {

        // Check for all emirps inside an array of primes
        for (int prime : source_primes) {
            if (isEmirp(prime)) {
                emirps.insert(emirps.end(), prime);
            }
        }
    }
    return emirps;
}

int main(int argc, char* argv[])
{
    if (argc &gt; 1)
    {
        multithread_enable = strcmp(argv[1], "--no-thread") != 0;
    }

    int N = 0;
    cout &lt;&lt; "N ra vared konid: ";
    cin &gt;&gt; N;

    // Value gaurds
    if (N &lt; 1) {
        cout &lt;&lt; "N na motabar!" &lt;&lt; endl;
        return -1;
    }
    if (N == 1 || N == 2 || N == 3) {
        cout &lt;&lt; N &lt;&lt; "-omin adad double aval " &lt;&lt; (N &lt; 3 ? N + 1 : 5) &lt;&lt; " mibashad" &lt;&lt; endl;
        return 0;
    }

    // Approximately how many primes we need to find to get N emirps
    int primesN = N * log10(N);

    // Approximately, we need to find primes less than this to get N emirps
    int limit = (log(primesN) + 1) * primesN;

    // Generate primes upto limit
    vector&lt;int&gt; primes = primes_in_range(0, limit, multithread_enable);
    // Set the global primes
    check_primes = primes;
    // Find the emirps inside primes
    vector&lt;int&gt; emirps = find_emirps(primes, multithread_enable);

    // If we still don't have enough emirps, generate from limit + 1 to 2 * limit
    // and then from 2 * limit to 3 * limit and so on until we have N emirps
    for (float i = 1; emirps.size() &lt; N; i += 0.1) {
        primes = primes_in_range(limit * i + 1, limit * (i + 0.1), multithread_enable);
        auto new_emirps = find_emirps(primes, multithread_enable);
        emirps.insert(emirps.end(), new_emirps.begin(), new_emirps.end());
    }

    cout &lt;&lt; N &lt;&lt; "-omin adad double aval " &lt;&lt; emirps[N - 1] &lt;&lt; " mibashad" &lt;&lt; endl;
    return 0;
}</code>
    </pre>
        <h3 class="desc-heading">الگوریتم:</h3>
        <p class="desc">
        <ul class="algo-list">
            <li>
                برای پیدا کردن N امین عدد دوبل اول، باید تقریبا \(N \times \log_{10}(N)\) عدد اول پیدا کنیم. همچنین برای
                پیدا کردن X
                عدد
                اول، باید تمام اعداد اول از صفر تا تقریبا \((\log_e(X) + 1) \times X\) را پیدا کنیم
            </li>
            <li>
                برای پیدا کردن اعداد اول بین 0 و N میتوانیم از الگوریتم غربال اراتوستن استفاده کنیم. در این الگوریتم ما
                تمام
                مضرب های هر عدد اول تا رادیکال N را حذف می کنیم و چیزی که باقی می ماند، اعداد اول است
            </li>
            <li>
                سپس، هر کدام از آن اعداد اول را امتحان میکنیم و بررسی میکنیم که آیا برعکس شان نیز اول هست یا نه. برای چک کردن
                اول
                بودن عدد نیز، کافی است تمام اعداد اول تا رادیکال آن عدد را با غربال پیدا کنیم و اگر عدد بر هیچ کدام از
                آنها
                بخش پذیر نبود، اول است
            </li>
            <li>
                از آنجایی که این دو فرمول تقریبی هستند، ممکن است ما در نهایت به تعداد کافی عدد دوبل اول نداشته باشیم. به
                همین خاطر، اگر که تعداد اعداد پیدا شده کافی نبود، الگوریتم اعداد دوبل اول بین N و 1.1 * N را پیدا میکند.
                این
                کار را تا جایی انجام می دهیم تا به تعداد کافی عدد پیدا کرده باشیم
            </li>
            <li>
                همچنین، الگوریتم برای بهینه تر بودن، از تمام هسته های پردازنده استفاده کرده و با تقسیم کار، محاسبه را
                سریعتر
                انجام میدهد. برای تقسیم کردن کار به بخش های کوچکتر، لازم است الگوریتم غربال ما بتواند اعداد اول بین دو
                عدد،
                با شروع غیر از 0 را نیز محاسبه کند. برای این کار کافی است الگوریتم را کمی تغییر دهیم تا تمام مضرب های
                اعداد
                اول بین 0 و نقطه پایان که بزرگتر از نقطه شروع هستند را حذف کند
            </li>
            <li>
                برای جلوگیری از محسابه مجدد اعداد اول برای مراحل مختلف، پس از محاسبه اعداد اول، آنها را در یک
                متغیر
                عمومی برای استفاده های بعدی ذخیره میکنیم
        </ul>
        </p>
    </section>

    <!-- Page 3 -->
    <section class="page page-3">
        <h3 class="page-heading">سوال ۲:</h2>
        <pre>
            <code class="language-cpp">#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;math.h&gt;
#include &lt;string&gt;

using namespace std;

// Part A
int smallest_larger(int n)
{
    string num = to_string(n);
    int a_index;
    int b_index;
    char largest = 0;
    cout &lt;&lt; endl;
    // Start reading the num from right to left
    for (int i = num.size() - 1; i &gt;= 0; i--) {
        // Find the largest digit
        if (num[i] &gt; largest) {
            largest = num[i];
            // The first smaller digit than our largest
        } else if (num[i] &lt; largest) {
            a_index = i;
            char smallest_b = 127;
            // Find the smallest digit to the right of a, that is larger than a (mark it as b)
            for (int j = i; j &lt; num.size(); j++) {
                if (num[j] &gt; num[a_index] &amp;&amp; num[j] &lt; smallest_b) {
                    smallest_b = num[j];
                    b_index = j;
                }
            }
            // Swap a and b values
            char temp = num[a_index];
            num[a_index] = num[b_index];
            num[b_index] = temp;
            // Sort digits to the right of b (but not b itself) (since we have swapped, b is now in the position of a)
            sort(num.begin() + a_index + 1, num.end());
            break;
        }
    }
    // If the result is the same, it means it's impossible to do
    int result = stoi(num);
    if (result == n) {
        return -1;
    }
    return result;
}

// Part B
int largest_smaller(int n)
{
    string num = to_string(n);
    int a_index;
    int b_index;
    char smallest = 127;
    cout &lt;&lt; endl;
    // Start reading the num from right to left
    for (int i = num.size() - 1; i &gt;= 0; i--) {
        // Find the smallest digit
        if (num[i] &lt; smallest) {
            smallest = num[i];
            // the first larger digit than the our smallest
        } else if (num[i] &gt; smallest) {
            a_index = i;
            char largest_b = 0;
            // Find the largest digit to the right of a that is smaller than a (mark it as b)
            for (int j = i; j &lt; num.size(); j++) {
                if (num[j] &lt; num[a_index] &amp;&amp; num[j] &gt; largest_b) {
                    largest_b = num[j];
                    b_index = j;
                }
            }
            // Swap the values of a and b
            char temp = num[a_index];
            num[a_index] = num[b_index];
            num[b_index] = temp;
            // Sort digits to the right of b in descending order (but not b iself) (since we have swapped, b is now in the position of a)
            sort(num.begin() + a_index + 1, num.end(), greater&lt;&gt;());
            break;
        }
    }
    // If the result is the same, it means it's impossible
    int result = stoi(num);
    if (result == n) {
        return -1;
    }
    return result;
}

int main(int argc, char* argv[])
{
    int input;
    cout &lt;&lt; "Adad ra vared konid: ";
    cin &gt;&gt; input;
    int smallest = smallest_larger(input);
    int largest = largest_smaller(input);
    cout &lt;&lt; "A: " &lt;&lt; (smallest == -1 ? "impossible" : to_string(smallest)) &lt;&lt; endl;
    cout &lt;&lt; "B: " &lt;&lt; (largest == -1 ? "impossible" : to_string(largest)) &lt;&lt; endl;
    return 0;
}</code>
        </pre>
        <h3 class="desc-heading">الگوریتم:</h3>
        <p class="desc">
        <h4 class="desc-sub-heading">بخش الف:</h4>
        <ul class="algo-list">
            <li>
                شروع به خواندن ارقام از راست به چپ کن
            </li>
            <li>
                بزگترین رقمی که تا الان دیده شده را با یاد داشته باش
            </li>
            <li>
                اگر این رقم از بزرگترین رقم تا به حال دیده شده کوچکتر بود، آن را به عنوان \(a\) علامت گذاری کن
            </li>
            <li>
                کوچکترین رقم سمت راست \(a\) که از خود \(a\) بزرگتر است را پیدا کن و آن را به عنوان \(b\) علامت گذاری کن
            </li>
            <li>
                جای \(a\) و \(b\) را عوض کن
            </li>
            <li>
                ارقام سمت راست \(b\) را از کوچکتر به بزرگتر مرتب کن
            </li>
            <li>
                اگر عدد به دست آمده با عدد اولیه فرقی نداشت، عمل غیر ممکن است
            </li>
        </ul>
        <div style="page-break-after: always;"></div>
        <h4 class="desc-sub-heading">بخش ب:</h4>
        <ul class="algo-list">
            <li>
                شروع به خواندن ارقام از راست به چپ کن
            </li>
            <li>
                کوچکترین رقمی که تا الان دیده شده را با یاد داشته باش
            </li>
            <li>
                اگر این رقم از کوچکترین رقم تا به حال دیده شده بزرگتر بود، آن را به عنوان \(a\) علامت گذاری کن
            </li>
            <li>
                بزرگترین رقم سمت راست \(a\) که از خود \(a\) کوچکتر است را پیدا کن و آن را به عنوان \(b\) علامت گذاری کن
            </li>
            <li>
                جای \(a\) و \(b\) را عوض کن
            </li>
            <li>
                ارقام سمت راست \(b\) را از بزرگتر به کوچکتر مرتب کن
            </li>
            <li>
                اگر عدد به دست آمده با عدد اولیه فرقی نداشت، عمل غیر ممکن است
            </li>
        </ul>
        </p>
    </section>

    <!-- Page 4 -->
    <section class="page page-4">
        <h3 class="page-heading">سوال ۳:</h2>
        <pre>
                <code class="language-cpp">#include &lt;iostream&gt;
#include &lt;math.h&gt;

using namespace std;

int main(int argc, char* argv[])
{
    int years, increase_percentage;
    cout &lt;&lt; "Tedad sal va darsad afzayesh hoghoogh ra vared konid: ";
    cin &gt;&gt; years &gt;&gt; increase_percentage;
    // Formula: (((present / past) ^ 1 / years) - 1) * 100
    cout &lt;&lt; "Miangin darsad afzayesh saliane: " &lt;&lt; ceil((pow((100 + increase_percentage) / 100.0, 1.0 / years) - 1.0) * 100) &lt;&lt; endl;
    return 0;
}</code>
            </pre>
        <p class="desc">
        <h3 class="desc-heading">الگوریتم:</h3>
        <ul class="algo-list">
            <li>
                برای به دست آوردن میانگین درصد افزایش سالیانه کافی است از فرمول زیر استفاده کنیم:
                \[Avg = \left[\left(\frac{100 + increase\_percentage}{100}\right)^\frac{1}{years} - 1\right] \times 100
                \]
            </li>
        </ul>
        </p>
    </section>
    <section class="page page-5">
        <h3 class="page-heading">سوال ۴:</h2>
        <pre>
                <code class="language-cpp">#include &lt;algorithm&gt;
#include &lt;future&gt;
#include &lt;iostream&gt;
#include &lt;math.h&gt;
#include &lt;numeric&gt;
#include &lt;thread&gt;
#include &lt;unordered_map&gt;
#include &lt;vector&gt;
#include &lt;string.h&gt;

using namespace std;

const auto CORE_COUNT = thread::hardware_concurrency();

vector&lt;int&gt; primes_in_range(int start, int end, bool multithreaded = true);

bool multithread_enable = true;

// Find all the primes from start to end (containing both start and end if they are prime)
vector&lt;int&gt; primes_in_range(int start, int end, bool multithreaded)
{
    vector&lt;int&gt; primes;
    // Do multi-threading if its worth it
    if (multithreaded &amp;&amp; end - start &gt; 1000) {
        int count = end - start + 1;
        vector&lt;future&lt;vector&lt;int&gt;&gt;&gt; futures;
        // Division size minimum is 100
        int division_size = max&lt;int&gt;(100, count / CORE_COUNT);
        // Start the different threads, calculating different divisions of primes
        for (int s = start; s &lt;= end; s++) {
            int e = min&lt;int&gt;(s + division_size, end);
            futures.insert(futures.end(), async(primes_in_range, s, e, false));
            s = e;
        }
        // Get the thread results and append them to the list of primes
        for (auto&amp; f : futures) {
            auto result = f.get();
            primes.insert(primes.end(), result.begin(), result.end());
        }
        // Sort the primes because threads don't respect order
        sort(primes.begin(), primes.end());

    } else {
        // If we are doing classical sieve (starting from 0)
        if (start &lt;= 2) {
            // The sieve bool array
            vector&lt;bool&gt; sieve(end + 1, true);
            // Remove even numbers except 2
            for (int i = 4; i &lt; sieve.size(); i += 2) {
                sieve[i] = false;
            }
            // Remove multiples of 3 except 3 itself
            for (int i = 9; i &lt; sieve.size(); i += 6) {
                sieve[i] = false;
            }
            // 0 and 1 are not prime
            sieve[0] = sieve[1] = false;
            // For each odd number less than sqrt(end) starting from 5 (2 and 3 are already done)...
            for (int i = 5; i &lt;= sqrt(end); i += 2) {
                // If i is prime
                if (sieve[i]) {
                    // Start from i^2 and remove all multiples of i (auto skipping even numbers)
                    for (int j = pow&lt;int, int&gt;(i, 2); j &lt; sieve.size(); j += i * 2) {
                        sieve[j] = false;
                    }
                }
            }
            // Add 2 as a prime (so we can skip all evens in the next loop)
            primes.insert(primes.end(), 2);
            // Add all primes (skipping even numbers, and 2 is already added) to the primes vector
            for (int i = 3; i &lt; sieve.size(); i += 2) {
                if (sieve[i]) {
                    primes.insert(primes.end(), i);
                }
            }
        } else {
            // Segmented sieve
            int count = end - start + 1;
            // The sieve array (offset by start, meaning sieve[0] is the start and sieve.back() is the end)
            vector&lt;bool&gt; sieve(count, true);
            // Remove even numbers
            for (int i = start % 2; i &lt; sieve.size(); i += 2) {
                sieve[i] = false;
            }
            // Calculate primes before sqrt(end)
            vector&lt;int&gt; primes_until_sqrt = primes_in_range(0, sqrt(end), multithreaded);
            // For all the primes except 2 (even numbers are already removed)...
            for (int i = 1; i &lt; primes_until_sqrt.size(); i++) {
                // Remove all the multiples of this prime
                for (int j = max&lt;int&gt;(ceil(static_cast&lt;double&gt;(start) / primes_until_sqrt[i]), primes_until_sqrt[i]);
                        j &lt;= end / primes_until_sqrt[i]; j++) {
                    sieve[(primes_until_sqrt[i] * j) - start] = false;
                }
            }
            // Add all the primes (auto skipping evens)
            for (int i = !(start % 2); i &lt; sieve.size(); i += 2) {
                if (sieve[i]) {
                    primes.insert(primes.end(), i + start);
                }
            }
        }
    }
    // Primes array now has all the primes from start and end
    return primes;
}

// Part A
int no_expo(int n)
{
    vector&lt;int&gt; nums;
    // Generate at least N primes
    vector&lt;int&gt; primes = primes_in_range(0, (log(n) + 1) * n, multithread_enable);
    int smallest_prime = primes[0];
    int next_smallest = primes[1];
    // Multiply the smallest prime by its next smallest prime and then go to the next prime
    for (int i = 0; i &lt; primes.size(); i++) {
        // Until the result is bigger than the last prime
        if (primes[i] * primes[i + 1] &gt; primes.back())
            break;
        for (int j = i + 1; j &lt; primes.size(); j++) {
            if (primes[i] * primes[j] &lt; primes.back()) {
                nums.insert(nums.end(), primes[i] * primes[j]);
            } else
                break;
        }
    }
    // Insert the primes into the results
    nums.insert(nums.end(), primes.begin(), primes.end());
    // Sort them
    sort(nums.begin(), nums.end());
    return nums[n - 1];
}

// Part B
int lot_expo(int n)
{
    long double limit = pow(n, 2);
    vector&lt;bool&gt; sieve(n + 1, true);
    vector&lt;long int&gt; nums;
    // Generate the power of numbers from 2-n that are smaller than limit
    for (int i = 2; i &lt; sieve.size(); i++) {
        if (sieve[i]) {
            int expo = 2;
            long int power = pow(i, expo);
            while (power &lt;= limit) {
                nums.insert(nums.end(), power);
                if (power &lt;= n) {
                    sieve[power] = false;
                }
                expo++;
                power = pow(i, expo);
            }
        }
    }
    // 1 is also powerful
    nums.insert(nums.end(), 1);
    sort(nums.begin(), nums.end());
    // Multiply the powers by other powers until the result is bigger than limit
    for (int i = 1; i &lt; nums.size(); i++) {
        if (nums[i] * nums[i + 1] &gt; limit) {
            break;
        } else {
            for (int j = i + 1; j &lt; nums.size(); j++) {
                long int res = nums[i] * nums[j];
                if (res &gt; limit) {
                    break;
                } else if (find(nums.begin(), nums.end(), res) == nums.end()) {
                    nums.insert(nums.end(), res);
                }
            }
        }
    }
    // Sort them
    sort(nums.begin(), nums.end());
    return nums[n - 1];
}

int main(int argc, char* argv[])
{
    if (argc &gt; 1)
    {
        multithread_enable = strcmp(argv[1], "--no-thread") != 0;
    }
    int n;
    cout &lt;&lt; "n ra vared konid: ";
    cin &gt;&gt; n;
    cout &lt;&lt; endl;
    cout &lt;&lt; n &lt;&lt; "-omin adad bi tavan " &lt;&lt; no_expo(n) &lt;&lt; " mibashad" &lt;&lt; endl;
    cout &lt;&lt; n &lt;&lt; "-omin adad por tavan " &lt;&lt; lot_expo(n) &lt;&lt; " mibashad" &lt;&lt; endl;
    return 0;
}</code>
                    </pre>
        <h3 class="desc-heading">الگوریتم:</h3>
        <p class="desc">
        <h4 class="desc-sub-heading">بخش الف:</h4>
        <ul class="algo-list">
            <li>
                N عدد اول پیدا کن
            </li>
            <li>
                برای پیدا کردن N عدد اول، میتوان تمام اعداد اول بین 0 و \(N \times \left(\log_e(N) + 1\right)\) را پیدا
                کرد. با این روش ما حداقل N عدد اول به دست می آوریم
            </li>
            <li>
                کوچکترین عدد اول را در عدد بزرگتر بعدش ضرب می کنیم. جواب را در لیست جواب ها ذخیره میکنیم
            </li>
            <li>
            عدد دوم را به عدد اول بزرگتر بعدی تغییر میدهیم
            </li>
            <li>
                این کار را تا زمانی که نتیجه از بزرگترین عدد اول، بزرگتر باشد انجام میدهیم
            </li>
            <li>
                سپس عامل اول ضرب رو به عدد بزرگتر بعد از آن تغییر میدهیم و مراحل را تکرار میکنیم
            </li>
            <li>
                زمانی که پس از تغییر عامل اول، اولین ضرب بزرگتر از بزرگترین عدد اول بود، توقف میکنیم
            </li>
            <li>
                اعداد اول را به لیست جواب ها اضافه میکنیم
            </li>
            <li>
                لیست را از کوچک به بزرگ مرتب می کنیم
            </li>
            <li>
                N امین عضو لیست، جواب بخش الف است
            </li>
        </ul>
        <div style="page-break-after: always;"></div>
        <h4 class="desc-sub-heading">بخش ب:</h4>
        <ul class="algo-list">
            <li>
                تمام اعداد از 2 تا N را در لیست اولیه ذخیره کن
            </li>
            <li>
                نکته: لیست اولیه در برنامه به صورت یک آرایه صحیح و غلط نمایش داده شده است. صحیح بودن یک عضو در آرایه به
                منزله وجود آن عضو در لیست اعداد بوده وغلط بودن به منزله حذف شدن میباشد
            </li>
            <li>
                از اولین عدد در لیست شروع کن و توان دوم آن را در لیست جاب ها ذخیره کن
            </li>
            <li>
                اگر که توان دوم در لیست اولیه بود، آن را حذف کن
            </li>
            <li>
                این کار را برای تمام اعداد موجود در لیست اولیه انجام بده
            </li>
            <li>
                در لیست جواب ها، هر عدد را در عدد بعدی بزرگتر از خودش ضرب کن تا جایی که جواب بزرگتر از \(N^2\) باشد
            </li>
            <li>
                عدد ۱ را نیز به لیست جواب ها اضافه کن
            </li>
            <li>
                جواب ها را از کوچک به بزرگ مرتب کن
            </li>
            <li>
                N امین عضو لیست، جواب بخش ب است
            </li>
        </ul>
        </p>
    </section>
    <section class="page page-6">
        <h3 class="page-heading">سوال ۵:</h2>
        <pre>
            <code class="language-cpp">#include &lt;algorithm&gt;
#include &lt;future&gt;
#include &lt;iostream&gt;
#include &lt;math.h&gt;
#include &lt;numeric&gt;
#include &lt;thread&gt;
#include &lt;vector&gt;
#include &lt;string.h&gt;

using namespace std;

const auto CORE_COUNT = std::thread::hardware_concurrency();

vector&lt;int&gt; primes_in_range(int start, int end, bool multithreaded = true, bool count = false);

// Returns all primes between start and end if count = false, else { count } of primes between start and end
vector&lt;int&gt; primes_in_range(int start, int end, bool multithreaded, bool count)
{
    vector&lt;int&gt; primes;
    // Do multi-threading if its worth it
    if (multithreaded &amp;&amp; end - start &gt; 1000) {
        int n = end - start + 1;
        vector&lt;future&lt;vector&lt;int&gt;&gt;&gt; futures;
        // Division size minimum is 100
        int division_size = max&lt;int&gt;(100, n / CORE_COUNT);
        // Start the different threads, calculating different divisions of primes
        for (int s = start; s &lt;= end; s++) {
            int e = min&lt;int&gt;(s + division_size, end);
            if (s == start) {
                futures.insert(futures.end(), async(primes_in_range, s, e + 1, false, count));
            } else if (e == end) {

                futures.insert(futures.end(), async(primes_in_range, s - 1, e, false, count));
            } else {
                futures.insert(futures.end(), async(primes_in_range, s - 1, e + 1, false, count));
            }
            s = e;
        }
        if (count) {
            primes.insert(primes.end(), 0);
        }
        // Get the thread results and append them to the list of primes
        for (auto&amp; f : futures) {
            auto result = f.get();
            if (count) {
                primes[0] += result[0];
            } else {
                primes.insert(primes.end(), result.begin(), result.end());
            }
        }
    } else {
        // If we are doing classical sieve (starting from 0)
        if (start &lt;= 2) {
            // The sieve bool array
            vector&lt;bool&gt; sieve(end + 1, true);
            // Remove even numbers except 2
            for (int i = 4; i &lt; sieve.size(); i += 2) {
                sieve[i] = false;
            }
            // Remove multiples of 3 except 3 itself
            for (int i = 9; i &lt; sieve.size(); i += 6) {
                sieve[i] = false;
            }
            // 0 and 1 are not prime
            sieve[0] = sieve[1] = false;
            // For each odd number less than sqrt(end) starting from 5 (2 and 3 are already done)...
            for (int i = 5; i &lt;= sqrt(end); i += 2) {
                // If i is prime
                if (sieve[i]) {
                    // Start from i^2 and remove all multiples of i (auto skipping even numbers)
                    for (int j = pow&lt;int, int&gt;(i, 2); j &lt; sieve.size(); j += i * 2) {
                        sieve[j] = false;
                    }
                }
            }
            if (count) {
                primes.insert(primes.end(), accumulate(sieve.begin(), sieve.end() - 1, (start == 2) ? -1 : 0));
            } else {
                if (start &lt; 2) {
                    primes.insert(primes.end(), 2);
                }
                // Add all primes (skipping even numbers, and 2 is already added) to the primes vector
                for (int i = 3; i &lt; sieve.size() - 1; i += 2) {
                    if (sieve[i]) {
                        primes.insert(primes.end(), i);
                    }
                }
            }
        } else {
            // Segmented sieve
            int n = end - start + 1;
            // The sieve array (offset by start, meaning sieve[0] is the start and sieve.back() is the end)
            vector&lt;bool&gt; sieve(n, true);
            // Remove even numbers
            for (int i = start % 2; i &lt; sieve.size(); i += 2) {
                sieve[i] = false;
            }
            // Calculate primes before sqrt(end)
            vector&lt;int&gt; primes_until_sqrt = primes_in_range(0, sqrt(end) + 1, multithreaded);
            // For all the primes except 2 (even numbers are already removed)...
            for (int i = 1; i &lt; primes_until_sqrt.size(); i++) {
                // Remove all the multiples of this prime
                for (int j = max&lt;int&gt;(ceil(static_cast&lt;double&gt;(start) / primes_until_sqrt[i]), primes_until_sqrt[i]); j &lt;= end / primes_until_sqrt[i]; j++) {
                    sieve[(primes_until_sqrt[i] * j) - start] = false;
                }
            }
            if (count) {
                primes.insert(primes.end(), accumulate(sieve.begin() + 1, sieve.end() - 1, 0));
            } else {
                // Add all the primes (auto skipping evens)
                for (int i = (start % 2) + 1; i &lt; sieve.size() - 1; i += 2) {
                    if (sieve[i]) {
                        primes.insert(primes.end(), i + start);
                    }
                }
            }
        }
    }
    return primes;
}
int main(int argc, char* argv[])
{
    bool multithread_enable = true;
    if (argc &gt; 1)
    {
        multithread_enable = strcmp(argv[1], "--no-thread") != 0;
    }
    int line_count;
    cout &lt;&lt; "q ra vared konid: ";
    cin &gt;&gt; line_count;
    cout &lt;&lt; endl;
    vector&lt;int&gt; counts(line_count);
    vector&lt;vector&lt;int&gt;&gt; start_end_pairs(line_count);
    // Ask for each line
    for (int i = 1; i &lt;= line_count; i++) {
        start_end_pairs[i - 1] = vector&lt;int&gt;(2);
        cout &lt;&lt; "Khat " &lt;&lt; i &lt;&lt; " ra vared konid: ";
        cin &gt;&gt; start_end_pairs[i - 1][0] &gt;&gt; start_end_pairs[i - 1][1];
        cout &lt;&lt; endl;
    }
    // Calculate each line's primes
    for (auto pair : start_end_pairs) {
        cout &lt;&lt; "Tedad adad aval bein " &lt;&lt; pair[0] &lt;&lt; " va " &lt;&lt; pair[1] &lt;&lt; ": " &lt;&lt; primes_in_range(pair[0], pair[1], multithread_enable, true)[0] &lt;&lt; endl;
    }
    return 0;
}</code>
        </pre>
        <h3 class="desc-heading">الگوریتم:</h3>
        <p class="desc">
        <h4 class="desc-sub-heading">(در صورتی که شروع از 0 باشد)</h4>
        <ul class="algo-list">
            <li>
                در صورتی که شروع از عدد کوچکتر یا مساوری دو باشد، ما از الگوریتم غربال اراتوستن استفاده میکنیم
            </li>
            <li>
                در این الگوریتم، ابتدا پیش فرض میگیریم که همه اعداد از 2 تا N اول هستند
            </li>
            <li>
                سپس از اولین عدد اول شروع کرده و مضارب آن را به عنوان مرکب علامت گذاری می کنیم
            </li>
            <li>
                همین کار را برای تمام اعدادی که هنوز در لیست به عنوان اول علامت گذاری شده اند، انجام می دهیم
            </li>
            <li>
                در انتها اعدادی که هنوز اول هستند، همان اعداد اول بین 0 و N هستند
            </li>

            <li>
                همچنین فقط لازم است مضارب اعداد اول کوچکتر از رادیکال N را حذف کنیم
            </li>

        </ul>
        <h4 class="desc-sub-heading">(در صورتی که شروع از بزرگتر از 2 باشد)</h4>
        <ul class="algo-list">
            <li>
                برای پیدا کردن اعداد اول بین دو عدد با شروع بزرگتر از 2، باید الگوریتم غربال را کمی تغییر دهیم
            </li>
            <li>
                اول با استفاده از الگوریتم عادی غربال، اعداد اول از 0 تا رادیکال نقطه پایان را پیدا میکنیم
            </li>
            <li>
                سپس مضارب هر کدام از آن اعداد که در بازه انتخابی ما قرار دارد را حذف می کنیم
            </li>
        </ul>
        <h4 class="desc-sub-heading">بهینه سازی های کلی:</h4>
        <ul class="algo-list">
            <li>
                برای بهینه سازی الگوریتم میتوان مضارب 2 و 3 را همان اول از لیست حذف کرده و سپس برای پیدا کردن اعداد اول
                بعدی، "شش تا شش تا" بالا رفت
            </li>
            <li>
                از آنجایی که لیست اعداد به صورت یک آرایه صحیح و غلط در کد تعریف شده است (صحیح به معنای اول و غلط به
                معنای مرکب)، برای پیدا کردن تعداد فقط کافی است جمع اعضای آرایه را به دست آوریم، زیرا در تبدیل صحیح و غلط
                به اعداد صحیح، صحیح تبدیل به یک و غلط تبدیل به صفر میشود
            </li>
            <li>
                البته اگر خود اعداد مد نظر ما باشد (مثلا زمانی که الگوریتم تغییر داده شده اعداد اول تا رادیکال N را
                میخواهد) ما باید اعضای لیست را چک کرده و عضو های صحیح را به لیست جواب ها اضافه کنیم
            </li>
            <li>
                برای افزایش سرعت الگوریتم، برنامه طوری طراحی شده است تا از تمام هسته های پردازنده شما به صورت همزمان استفاده
                کند. البته این کار برای اعداد کوچکتر تاثیر آنچنانی ندارد، به همین دلیل این ویژگی فقط زمانی فعال میشود که
                بازه اعداد از 100 بزرگتر باشد
            </li>
        </ul>
        </p>
    </section>
    <section class="page page-7">
        <h3 class="page-heading">سوال ۶:</h2>
        <pre>
            <code class="language-cpp">#include &lt;algorithm&gt;
#include &lt;cctype&gt;
#include &lt;iostream&gt;
#include &lt;math.h&gt;
#include &lt;string&gt;
#include &lt;unordered_map&gt;

using namespace std;

const unordered_map&lt;string, int&gt; days = {
    { "saturday", 0 },
    { "sunday", 1 },
    { "monday", 2 },
    { "tuesday", 3 },
    { "wednesday", 4 },
    { "thursday", 5 },
    { "friday", 6 }
};
const unordered_map&lt;int, int&gt; month_length = {
    { 1, 31 },
    { 2, 31 },
    { 3, 31 },
    { 4, 31 },
    { 5, 31 },
    { 6, 31 },
    { 7, 30 },
    { 8, 30 },
    { 9, 30 },
    { 10, 30 },
    { 11, 30 },
    { 12, 30 }
};

int main(int argc, char* argv[])
{
    string day;
    int day_in_week;
    int first_month;
    int first_date;
    int second_date;
    int second_month;
    cout &lt;&lt; "Rooz va tarikh ra vared konid: ";
    cin &gt;&gt; first_date &gt;&gt; first_month &gt;&gt; day;
    cout &lt;&lt; "Tarikh na maloom ra vared konid: ";
    cin &gt;&gt; second_date &gt;&gt; second_month;
    cout &lt;&lt; endl;
    // Lowercase the day
    transform(day.begin(), day.end(), day.begin(),
        [](unsigned char c) { return tolower(c); });
    try {
        day_in_week = days.at(day);
    } catch (const out_of_range&amp;) {
        cout &lt;&lt; "Rooz na motabar!" &lt;&lt; endl;
        return -1;
    }
    int days_past;

    if (first_month == second_month) {
        // If they are both in the same month
        days_past = second_date - first_date;
    } else if (second_month &gt; first_month) {
        // If we are going forwards
        days_past = (month_length.at(first_month) - first_date) + second_date;
        for (int i = first_month + 1; i &lt; second_month; i++) {
            days_past += month_length.at(i);
        }
    } else {
        // If we are going backwards
        days_past = -(month_length.at(second_month) - second_date + first_date);
        for (int i = first_month - 1; i &gt; second_month; i--) {
            days_past -= month_length.at(i);
        }
    }
    // Calculate the new day in the week
    int new_day_in_week = (7 + (day_in_week + (days_past % 7))) % 7;
    string new_day;
    // Find the new day's name
    for (auto&amp; day : days) {
        if (day.second == new_day_in_week) {
            new_day = day.first;
            break;
        }
    }
    // Upper case first letter
    new_day[0] = toupper(new_day[0]);
    cout &lt;&lt; new_day &lt;&lt; endl;
    return 0;
}</code>
        </pre>
        <h3 class="desc-heading">الگوریتم:</h3>
        <p class="desc">
        <ul class="algo-list">
            <li>
                برای حل سوال ابتدا باید حساب کنیم دو تاریخ چند روز با هم فاصله دارند
            </li>
            <li>
                اگر که دو تاریخ در یک ماه باشند، فقط کافی است تاریخ دوم را منهای تاریخ اول کنیم
            </li>
            <li>
                در غیر این صورت باید ابتدا تعداد روز های همه ماه های بین دو ماه تاریخ اول و دوم را حساب کنیم
            </li>
            <li>
                سپس روز های باقی مانده به پایان ماه در تاریخ اول و روز های گذشته از شروع ماه را در تاریخ دوم حساب کنیم
            </li>
            <li>
                با جمع این دو میتوان تعداد روز های طی شده را به دست آورد
            </li>
            <li>
                اگر که روز های طی شده منفی باشد، باید به عقب پیش برویم
            </li>
            <li>
                حالا کافی است تا باقی مانده روز ها بر 7 را حساب کنیم و آن عدد را به شماره روز اول در هفته جمع کنیم
            </li>
            <li>
                برای انجام محاسبه درست در حالت هایی مثل ترتیب برعکس (روز طی شده منفی) و یا دو روز در یک ماه، لازم است
                تدابیر جزئی ای نیز لحاظ شود که در برنامه انجام شده
            </li>
        </ul>
        </p>
    </section>
    <section class="page page-8">
        <h3 class="page-heading">سوال ۷:</h2>
        <pre>
            <code class="language-cpp">#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;vector&gt;

using namespace std;

int main(int argc, char* argv[])
{
    int numCount;

    cout &lt;&lt; "Tedade adad ha ra vared konid: ";
    cin &gt;&gt; numCount;

    vector&lt;int&gt; numbers(numCount);

    cout &lt;&lt; "Adad ha ra vared konid: ";

    for (int i = 0; i &lt; numCount; i++) {
        cin &gt;&gt; numbers[i];
    }

    sort(numbers.begin(), numbers.end());

    cout &lt;&lt; "Adad haye moratab shode: " &lt;&lt; endl;

    for (int num : numbers) {
        cout &lt;&lt; num &lt;&lt; ' ';
    }
    cout &lt;&lt; endl;

    return 0;
}</code>
        </pre>
        <h3 class="desc-heading">الگوریتم:</h3>
        <p class="desc">
        <ul class="algo-list">
            <li>
                در این سوال از تابع sort در کتابخانه استاندارد ++C استفاده شده است. این تابع از الگوریتم IntroSort
                استفاده میکند که ترکیبی از Quicksort, Insertion Sort و Heap Sort می باشد. این الگوریتم یکی از سریعترین و
                بهینه ترین الگوریتم های مرتب کردن اعداد می باشد
            </li>
        </ul>
        </p>
    </section>
    <section class="page page-9">
        <h3 class="page-heading">سوال ۸:</h2>
        <pre>
            <code class="language-cpp">#include &lt;iostream&gt;
#include &lt;math.h&gt;

using namespace std;

// Find the decade the number is in (the 10 base power + 1)
inline int find_decade(int n, int&amp; sum_before)
{
    int digits = 0;
    int sum = 0;
    int result = 1;
    while (digits &lt; n) {
        digits = result * 9 * pow(10, result - 1);
        sum += digits;
        result++;
    }
    // Result is off by one
    result--;
    // Make sum have the sum of all decades before our decade
    sum -= digits;
    sum_before = sum;
    return result;
}

int main(int argc, char* argv[])
{
    int n;
    cout &lt;&lt; "n ra vared konid: ";
    cin &gt;&gt; n;
    cout &lt;&lt; endl;
    int sum_bfore = 0;
    int decade = find_decade(n, sum_bfore);
    // Eg. If you want the 11th digit, it means the 2nd digit in the 2 decade, and 2nd is the value stored here
    int n_digit_in_decade = n - sum_bfore;
    // Eg. If you want the 11th digit, It will be part of the 1st number of the 2 decade, and 1st is stored here
    int n_number_in_decade = ceil(static_cast&lt;double&gt;(n_digit_in_decade) / decade);
    // Eg. If you want the 11th digit, It will be part of 10, and 10 is stored in here
    int num = (n_number_in_decade - 1) + pow(10, decade - 1);
    int digit = static_cast&lt;int&gt;(num / pow(10, decade - ((n_digit_in_decade - 1) % decade) - 1)) % 10; // Calculate the digit
    cout &lt;&lt; n &lt;&lt; "-omin adad donbale: " &lt;&lt; digit &lt;&lt; endl;
    return 0;
}</code>
        </pre>
        <h3 class="desc-heading">الگوریتم:</h3>
        <p>
        <ul class="algo-list">
            <li>
                ابتدا باید پیدا کنیم که N امین رقم در دهه اعداد چند رقمی است
            </li>
            <li>
                برای پیدا کردن دهه، از اولین دهه (اعداد ی رقمی شروع کرده) و تعداد رقم های هر دهه را به مجموع خود اضافه
                میکنیم تا جایی که مجموع از N بزرگتر شود. آخرین دهه قبل از بزرگتر شدن، دهه ای است که N امین رقم عضو آن
                است
            </li>
            <li>
                سپس پیدا می کنیم که N چندمین رقم در از شروع آن دهه است. برای این کار، کافی است فقط مجموع تعداد ارقام دهه های
                قبل را که در مرحله قبل محاسبه کردیم را از N کم کنیم
            </li>
            <li>
                سپس محسابه میکنیم که N امین رقم جزو عدد چندم از دهه است. برای این کار، ما تقریب بالای حاصل تقسیم نتیجه
                محاسبه مرحله بر شماره دهه را در نظر میگیریم
            </li>
            <li>
                سپس پیدا میکنیم که X امین عدد از دهه که در مرحله قبل پیدا کردیم، چه عددی است. برای این کار از فرمول زیر
                استفاده میکنیم:
                \[\left(nth\_number\_in\_decade - 1\right) + 10^{decade - 1}\]
            </li>
            <li>
                سپس برای محاسبه رقم با استفاده از اطلاعات به دست آمده، از فرمول زیر استفاده می کنیم. در اینجا decade
                همان شماره دهه، nth_digit_in_decade یعنی چندمین رقم از شروع دهه، و num همان عدد محاسبه شده در مرحله قبل
                است:
                \[\left\lfloor\frac{num}{10^{decade - \left(\left(nth\_digit\_in\_decade - 1\right) \mod decade\right) -
                1}}
                \mod 10\right\rfloor\]
            </li>
        </ul>
        </p>
    </section>
    <section class="page page-10">
        <h3 class="page-heading">سوال ۹:</h2>
        <pre>
            <code class="language-cpp">#include &lt;iostream&gt;
#include &lt;math.h&gt;
#include &lt;string&gt;
#include &lt;vector&gt;

using namespace std;

int main(int argc, char* argv[])
{
    int degree;
    vector&lt;int&gt; coefficients;
    cout &lt;&lt; "Daraje ra vared konid: ";
    cin &gt;&gt; degree;
    cout &lt;&lt; endl &lt;&lt; "Zarib ha ra vared konid: ";
    for (int i = 0; i &lt;= degree ; i++) {
        int c = 0;
        cin &gt;&gt; c;
        coefficients.push_back(c);
    }
    cout &lt;&lt; endl;
    // Find all the roots (non-negative integers less than 11)
    vector&lt;int&gt; roots;
    for (int i = 0; i &lt; 11; i++) {
        int result = 0;
        for (int j = degree; j &gt;= 0 ; j--) {
            result += coefficients[degree - j] * pow(i, j);
        }
        if (result == 0)
        {
            roots.push_back(i);
        }
    }
    // Build the polynomial
    string poly("");
    if (coefficients[0] &gt; 1)
    {
        poly += to_string(coefficients[0]) + " * "; 
    }
    for(int root : roots)
    {
        poly += ("(x - " + to_string(root) + ") * ");
    }
    // Replace (x - 0) with just x
    if (poly.find("(x - 0)") != string::npos)
    {
        poly.replace(poly.find("(x - 0)"), 7, "x");
    }
    // Remove the last " * "
    poly = poly.substr(0, poly.size() - 3);
    cout &lt;&lt; "Tajzie: " &lt;&lt; poly &lt;&lt; endl;
    return 0;
}</code>
        </pre>
        <h3 class="desc-heading">الگوریتم:</h3>
        <p class="desc">
        <ul class="algo-list">
            <li>
                برای تجزیه یک چند جمله ای با ریشه های مشخص، میتوان از قضیه فاکتور (Factor Theorem) استفاده کرد
            </li>
            <li>
                بر اساس این قضیه، به ازای هر ریشه \(a\) در ریشه های یک چند جلمه ای، \((x - a)\) یکی از فاکتور های آن چند
                جمله ای است
            </li>
            <li>
                از آنجایی که تضمین شده تمام ریشه ها اعداد صحیح هستند، لازم نیست نگران چند جمله ای هایی با ریشه های
                موهومی باشیم
            </li>
            <li>
                همچنین چون تمام ریشه ها غیر تکراری هستند، چند جمله ای های مربع کامل هم وجود ندارند
            </li>
            <li>
                برای استفاده از قضیه فاکتور ابتدا باید ریشه ها را پیدا کرد
            </li>
            <li>
                چون در این سوال تضمین شده ریشه ها فقط اعداد 0-10 باشند، میتوان با یک آزمون و خطای ساده تمام ریشه های چند
                جمله ای را پیدا کرد
            </li>
            <li>
                سپس با استفاده از قضیه فاکتور، تجزیه چند جمله ای را می سازیم
            </li>
            <li>
                در قضیه فاکتور، ضریب های ثابت پیدا نمی شوند، اما چون ریشه های چند جمله ای ما همگی اعداد صحیح هستند، تنها
                ضریب ثابت، ضریب بزرگترین درجه چند جمله ای است
            </li>
            <li>
                بنابراین اگر این ضریب بزرگتر از 1 بود، آن را به حاصل قضیه فاکتور اضافه میکنیم
            </li>
        </ul>
        </p>
    </section>
    <section class="page page-11">
        <h2 class="page-heading">سوال ۱۰:</h2>
        <pre>
            <code class="language-cpp">#include &lt;iostream&gt;
#include &lt;math.h&gt;

using namespace std;

long double factorial(int start, int end)
{
    long double result = max(start, 1);
    for (int i = result + 1; i &lt;= end; i++) {
        result *= i;
    }
    return result;
}

int main(int argc, char* argv[])
{
    int n, k;
    cout &lt;&lt; "n va k ra vared konid: ";
    cin &gt;&gt; n &gt;&gt; k;

    // Formula: (k + n)! / (k! * n!)
    long double top_part = k + n;
    // Simplify the division
    int bigger_one = max(k, n);
    top_part = factorial(bigger_one + 1, top_part);
    cout &lt;&lt; endl;
    long double result = top_part / factorial(1, min(n, k));
    cout &lt;&lt; result &lt;&lt; endl;
    return 0;
}</code>
        </pre>
        <p class="desc">
        <h3 class="desc-heading">
            الگوریتم:
        </h3>
        <ul class="algo-list">
            <li>
                اگر که برای یک لحظه در نظر بگیریم که سوال به جای کوچکتر یا مساوی، فقط حالت مساوی را از ما خواسته،
                میتوانیم سوال را با استفاده از یک مدل از توپ ها و میله ها حل کنیم
            </li>
            <li>
                اگر که ما N توپ داشته باشیم و انها را به صورت خطی جلوی هم بچینیم (مثال: N = 12):
                \[************\]
            </li>
            <li>
                با قرار دادن \(k - 1\) میله در میان آنها، میتوانیم آنها را به k قسمت تقسیم کنیم (مثال: k = 4):
                \[***|****|**|***\]
                \[3 + 4 + 2 + 3\]
            </li>
            <li>
                حالا اگر هر قسمت را به عنوان یکی از \(X_k\) ها در معادله در نظر بگیریم، با جابجایی میله ها میتوانیم تمام
                حالات ممکن برای برابری را بسازیم
            </li>
            <li>
                حالات ممکن برای این کار برابر است با:
                \[n + k - 1 \choose k - 1\]
            </li>
            <li>
                اما سوال حالات کوچکتر یا مساوی را از ما خواسته. برای حل این مشکل، کافی است به معادله \(X_1 + X_2 + ... +
                X_k = N\) یک متغیر جدید اضافه کنیم. این متغیر مسئولیت نگه داری باقی مانده تا مساوی، هنگامی که جمع X ها
                کمتر از N میشود را بر عهده دارد:
                \[X_1 + X_2 + ... + X_k \leq N \Rightarrow X_1 + X_2 + ... + X_k + y = N\]
            </li>
            <li>
                با اضافه کردن یک متغیر دیگر، تعداد حالات برابر میشود با:
                \[n + k \choose k\]
                یا همان:
                \[\left(k + n\right)! \over k! \times n!\]
            </li>
            <li>
                چون که صورت کسر همیشه بزرگتر از مخرج کسر می باشد، می شود فاکتوریل ها را ساده کرد. برای مثال اگر \(n =
                4\) و \(k = 6\):
                \[10! \over 6! \times 4!\]
            </li>
            <li>
                اگر \(10!\) را با عدد بزرگتر یعنی \(6!\) ساده کنیم، به نتیجه زیر می رسیم:
                \[\frac{10 \times 9 \times 8 \times 7}{4!}\]
                که از لحاظ محاسباتی سریعتر و ساده تر است
            </li>
            <li>
                پس در برنامه فقط لازم است عدد بزرگتر در مخرج را پیدا کرده و آن را با صورت ساده کنیم و سپس با محاسبه به جواب
                برسیم
            </li>
        </ul>
        </p>
    </section>
    <section class="page page-12">
        <h3 class="page-heading">سوال ۱۱:</h2>
        <pre>
            <code class="language-cpp">#include &lt;iostream&gt;
#include &lt;math.h&gt;
#include &lt;vector&gt;

using namespace std;

// 2^n digits repeat every 4 times
const int two_cyclic_digits[] = { 2, 4, 8, 6 };
// Get the last digit of 2^n
inline int unit_digit_of_2_expo(int expo)
{
    return two_cyclic_digits[(expo - 1) % 4];
}

// Factorial of 0-4
const int fact_map[] = { 1, 1, 2, 6, 24 };

int unit_digit_fact(int n)
{
    // the floor of 1/5th of n
    int n_5th_floor = floor(n / 5);
    // If n is small...
    if (n_5th_floor &lt; 5) {
        // Run the formula on it directly
        return (fact_map[n_5th_floor] * unit_digit_of_2_expo(n_5th_floor) * fact_map[n % 5]) % 10;
    } else {
        // Otherwise make it small
        // This variable stores the digits in the process of making it small
        int others = 1;
        while (n_5th_floor &gt; 4) {
            others = (unit_digit_of_2_expo(n_5th_floor) * fact_map[n % 5] * others) % 10;
            n = n_5th_floor;
            n_5th_floor = floor(n_5th_floor / 5);
        }
        // Run the formula
        return (fact_map[n_5th_floor] * unit_digit_of_2_expo(n_5th_floor) * fact_map[n % 5] * others) % 10;
    }
}
int main(int argc, char* argv[])
{
    int n = 0;
    cout &lt;&lt; "n ra vared konid: ";
    cin &gt;&gt; n;
    cout &lt;&lt; endl;
    cout &lt;&lt; unit_digit_fact(n) &lt;&lt; " avalin ragham na sefr dar " &lt;&lt; n &lt;&lt; "! mibashad"  &lt;&lt; endl;
    return 0;
}</code>
        </pre>
        <h3 class="desc-heading">الگوریتم:</h3>
        <p class="desc">
        <ul class="algo-list">
            <li>
                اگر که یک پنجم از N کوچکتر از 5 بود، با فرمول زیر اولین رقم غیر صفر در آن را محاسبه میکنیم:
                \[unit\_digit(n!) = {\left\lfloor {\frac{n}{5}} \right\rfloor !} \times 2^{\left\lfloor {\frac{n}{5}}
                \right\rfloor} \times \left(n \mod 5 \right)!\]
            </li>
            <li>
                در غیر این صورت، حاصل های قبلی را در \(2^{\left\lfloor\frac{n}{5}\right\rfloor} \times \left(n \mod 5
                \right)!\) ضرب کرده و n را تقسیم برپنج میکنیم
            </li>
            <li>
                این کار را اینقدر تکرار کرده تا \(n \over 5\) کوچکتر از 5 شود
            </li>
            <li>
                سپس، حاصل برابر است با اولین رقم در (results همان حاصل های قبلی در مراحل قبل است):
                \[\left(\left\lfloor n \over 5 \right\rfloor\right)! \times 2^{\left\lfloor n \over 5 \right\rfloor}
                \times \left(n \mod 5 \right)! \times results\]
            </li>
            <li>
                نکته: چون فقط ارقام اول مد نظر ماست، در محاسبات توان های دو فقط لازم است رقم اول را محاسبه کنیم و از
                آنجایی که ارقام توان های دو یک چرخه چهار تایی دارند، به راحتی قابل انجام است
            </li>
        </ul>
        </p>
    </section>
    <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/11.6.0/highlight.min.js"></script>
    <script>hljs.highlightAll();</script>
    <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
</body>

</html>
